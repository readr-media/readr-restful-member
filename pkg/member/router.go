package member

import (
	"encoding/json"
	"errors"
	"fmt"
	"log"
	"net/http"
	"strconv"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/readr-media/readr-restful-member/config"
	rt "github.com/readr-media/readr-restful-member/internal/router"
	"github.com/readr-media/readr-restful-member/internal/rrsql"
	"github.com/readr-media/readr-restful-member/internal/utils"
)

type memberHandler struct{}

func (r *memberHandler) bindQuery(c *gin.Context, args *GetMembersArgs) (err error) {

	args.SetDefault()
	if err = c.ShouldBindQuery(args); err != nil {
		// Return if error is other than Unknown type
		if err.Error() != "Unknown type" {
			return err
		}
	}
	log.Println(c.Query("active"))
	if c.Query("active") != "" {
		if err := json.Unmarshal([]byte(c.Query("active")), &args.Active); err != nil {
			return err
		} else if err == nil {
			// if err = rrsql.ValidateActive(args.Active, MemberStatus); err != nil {
			if err = rrsql.ValidateActive(args.Active, config.Config.Models.Members); err != nil {
				return err
			}
		}
	}
	if c.Query("role") != "" {
		var role int64
		if role, err = strconv.ParseInt(c.Query("role"), 10, 64); err != nil {
			return err
		}
		args.Role = &role
	}
	if c.Query("uuids") != "" {
		if err = json.Unmarshal([]byte(c.Query("uuids")), &args.UUIDs); err != nil {
			return err
		}
	}
	return nil
}

func bindKeywordsArgs(c *gin.Context, params *GetMembersKeywordsArgs) (err error) {
	if err = c.ShouldBindQuery(params); err != nil {
		log.Printf("Bind Keyword args error:%s\n", err.Error())
		return errors.New("Invalid keyword")
	}
	if c.Query("fields") != "" {
		if err = json.Unmarshal([]byte(c.Query("fields")), &params.Fields); err != nil {
			return errors.New("Invalid fields")
		}
	}
	if c.Query("roles") != "" {
		if err = json.Unmarshal([]byte(c.Query("roles")), &params.Roles); err != nil {
			return errors.New("Invalid roles")
		}
	}
	if err = params.Validate(); err != nil {
		return err
	}
	return err
}
func (r *memberHandler) GetAll(c *gin.Context) {

	var args = &GetMembersArgs{}
	err := r.bindQuery(c, args)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"Error": err.Error()})
		return
	}
	if args.Active == nil {
		args.DefaultActive()
	}
	var results struct {
		Items []Member         `json:"_items"`
		Meta  *rt.ResponseMeta `json:"_meta,omitempty"`
	}
	results.Items, err = MemberAPI.GetMembers(args)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"Error": err.Error()})
		return
	}
	if args.Total {
		totalMembers, err := MemberAPI.Count(args)
		if err != nil {
			c.JSON(http.StatusInternalServerError, gin.H{"Error": err.Error()})
			return
		}
		var MemberMeta = rt.ResponseMeta{
			Total: &totalMembers,
		}
		results.Meta = &MemberMeta
	}
	c.JSON(http.StatusOK, results)
}

func (r *memberHandler) Get(c *gin.Context) {

	id := c.Param("id")
	var idType string
	if _, err := strconv.Atoi(id); err != nil {
		idType = "member_id"
	} else {
		idType = "id"
	}

	member, err := MemberAPI.GetMember(GetMemberArgs{
		ID:     id,
		IDType: idType,
	})
	if err != nil {
		switch err.Error() {
		case "User Not Found":
			c.JSON(http.StatusNotFound, gin.H{"Error": "User Not Found"})
			return

		default:
			c.JSON(http.StatusInternalServerError, gin.H{"Error": "Internal Server Error"})
			return
		}
	}
	c.JSON(http.StatusOK, gin.H{"_items": []Member{member}})
}

func (r *memberHandler) Post(c *gin.Context) {

	member := Member{}
	c.Bind(&member)

	// Pre-request test
	// Must have MemberID, ID would be generated by database
	log.Println(member.Mail)
	if member.MemberID == "" && member.Mail.String == "" {
		c.JSON(http.StatusBadRequest, gin.H{"Error": "Invalid User"})
		return
	}
	if member.MemberID == "" {
		member.MemberID = member.Mail.String
	}

	if !member.CreatedAt.Valid {
		member.CreatedAt.Time = time.Now()
		member.CreatedAt.Valid = true
	}
	if !member.UpdatedAt.Valid {
		member.UpdatedAt.Time = time.Now()
		member.UpdatedAt.Valid = true
	}
	if !member.Active.Valid {
		member.Active = rrsql.NullInt{1, true}
	}
	if !member.Points.Valid {
		member.Points = rrsql.NullInt{0, true}
	}
	uuid, err := utils.NewUUIDv4()
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"Error": "Unable to generate uuid for user"})
		return
	}
	member.UUID = uuid.String()
	lastID, err := MemberAPI.InsertMember(member)
	if err != nil {
		switch err.Error() {
		case "Duplicate entry":
			c.JSON(http.StatusBadRequest, gin.H{"Error": "User Already Existed"})
			return
		default:
			c.JSON(http.StatusInternalServerError, gin.H{"Error": err.Error()})
			return
		}
	}
	resp := map[string]int{"last_id": lastID}
	c.JSON(http.StatusOK, gin.H{"_items": resp})
}

func (r *memberHandler) Put(c *gin.Context) {

	member := Member{}
	c.Bind(&member)
	// Use id field to check if Member Struct was binded successfully
	// If the binding failed, id would be emtpy string
	if member.ID == 0 {
		c.JSON(http.StatusBadRequest, gin.H{"Error": "Invalid Member Data"})
		return
	}
	if member.CreatedAt.Valid {
		member.CreatedAt.Time = time.Time{}
		member.CreatedAt.Valid = false
	}
	if !member.UpdatedAt.Valid {
		member.UpdatedAt.Time = time.Now()
		member.UpdatedAt.Valid = true
	}
	err := MemberAPI.UpdateMember(member)
	if err != nil {
		switch err.Error() {
		case "User Not Found":
			c.JSON(http.StatusBadRequest, gin.H{"Error": "User Not Found"})
			return
		default:
			c.JSON(http.StatusInternalServerError, gin.H{"Error": "Internal Server Error"})
			return
		}
	}
	c.Status(http.StatusOK)
}

func (r *memberHandler) DeleteAll(c *gin.Context) {
	ids := []int64{}
	err := json.Unmarshal([]byte(c.Query("ids")), &ids)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"Error": err.Error()})
		return
	}
	if len(ids) == 0 {
		c.JSON(http.StatusBadRequest, gin.H{"Error": "ID List Empty"})
		return
	}

	// err = MemberAPI.UpdateAll(ids, int(MemberStatus["delete"].(float64)))
	err = MemberAPI.UpdateAll(ids, config.Config.Models.Members["delete"])
	if err != nil {
		switch err.Error() {
		case "Members Not Found":
			c.JSON(http.StatusBadRequest, gin.H{"Error": "Members Not Found"})
			return
		default:
			c.JSON(http.StatusInternalServerError, gin.H{"Error": err.Error()})
			return
		}
	}
	c.Status(http.StatusOK)
}

func (r *memberHandler) Delete(c *gin.Context) {

	id := c.Param("id")
	err := MemberAPI.DeleteMember("id", id)
	if err != nil {
		switch err.Error() {
		case "User Not Found":
			c.JSON(http.StatusNotFound, gin.H{"Error": "User Not Found"})
			return
		default:
			c.JSON(http.StatusInternalServerError, gin.H{"Error": err.Error()})
			return
		}
	}
	c.Status(http.StatusOK)
}

func (r *memberHandler) ActivateAll(c *gin.Context) {
	payload := struct {
		IDs []int64 `json:"ids"`
	}{}
	err := c.Bind(&payload)
	if err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"Error": err.Error()})
		return
	}
	if payload.IDs == nil {
		c.JSON(http.StatusBadRequest, gin.H{"Error": "Invalid Request Body"})
		return
	}
	// err = MemberAPI.UpdateAll(payload.IDs, int(MemberStatus["active"].(float64)))
	err = MemberAPI.UpdateAll(payload.IDs, config.Config.Models.Members["active"])
	if err != nil {
		switch err.Error() {
		case "Members Not Found":
			c.JSON(http.StatusNotFound, gin.H{"Error": "Members Not Found"})
			return
		default:
			c.JSON(http.StatusInternalServerError, gin.H{"Error": err.Error()})
			return
		}
	}
	c.Status(http.StatusOK)
}

// MemberPutPasswordHandler let caller to update a member's password.
//
func (r *memberHandler) PutPassword(c *gin.Context) {

	input := struct {
		ID          string `json:"id"`
		NewPassword string `json:"password"`
		//OldPassword string `json="o"`
	}{}
	c.Bind(&input)

	if !utils.ValidateUserID(input.ID) || !utils.ValidatePassword(input.NewPassword) {
		c.JSON(http.StatusBadRequest, gin.H{"Error": "Invalid Input"})
		return
	}

	member, err := MemberAPI.GetMember(GetMemberArgs{
		ID:     input.ID,
		IDType: "id",
	})
	if err != nil {
		switch err.Error() {
		case "User Not Found":
			c.JSON(http.StatusNotFound, gin.H{"Error": "User Not Found"})
			return
		default:
			log.Println(err.Error())
			c.JSON(http.StatusInternalServerError, gin.H{"Error": fmt.Sprintf("Internal Server Error. %s", err.Error())})
			return
		}
	}

	/*
		oldHPW, err := utils.CryptGenHash(input.OldPassword, string(salt))
		if err != nil {
			log.Println(err.Error())
			c.JSON(http.StatusInternalServerError, gin.H{"Error": "Internal Server Error"})
			return
		}

		if oldHPW != member.Password.String {
			c.JSON(http.StatusUnauthorized, gin.H{"Error": "Wrong Password"})
		}
	*/

	// Gen salt and password
	salt, err := utils.CryptGenSalt()
	if err != nil {
		log.Println(err.Error())
		c.JSON(http.StatusInternalServerError, gin.H{"Error": fmt.Sprintf("Internal Server Error. %s", err.Error())})
		return
	}

	hpw, err := utils.CryptGenHash(input.NewPassword, string(salt))
	if err != nil {
		log.Println(err.Error())
		c.JSON(http.StatusInternalServerError, gin.H{"Error": fmt.Sprintf("Internal Server Error. %s", err.Error())})
		return
	}

	err = MemberAPI.UpdateMember(Member{
		ID:       member.ID,
		MemberID: member.MemberID,
		Password: rrsql.NullString{hpw, true},
		Salt:     rrsql.NullString{salt, true},
	})
	if err != nil {
		log.Println(err.Error())
		c.JSON(http.StatusInternalServerError, gin.H{"Error": fmt.Sprintf("Internal Server Error. %s", err.Error())})
		return
	}

	c.Status(http.StatusOK)
}

func (r *memberHandler) Count(c *gin.Context) {

	var args = &GetMembersArgs{}
	if err := r.bindQuery(c, args); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"Error": err.Error()})
		return
	}
	if args.Active == nil {
		args.DefaultActive()
	}
	count, err := MemberAPI.Count(args)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"Error": err.Error()})
		return
	}
	resp := map[string]int{"total": count}
	c.JSON(http.StatusOK, gin.H{"_meta": resp})
}

func (r *memberHandler) SearchKeyNickname(c *gin.Context) {

	args := GetMembersKeywordsArgs{}

	if err := bindKeywordsArgs(c, &args); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"Error": err.Error()})
		return
	}
	members, err := MemberAPI.GetIDsByNickname(args)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"Error": err.Error()})
		return
	}
	c.JSON(http.StatusOK, gin.H{"_items": members})
}

func (r *memberHandler) SetRoutes(router *gin.Engine) {

	memberRouter := router.Group("/member")
	{
		memberRouter.GET("/:id", r.Get)
		memberRouter.POST("", r.Post)
		memberRouter.PUT("", r.Put)
		memberRouter.DELETE("/:id", r.Delete)

		memberRouter.PUT("/password", r.PutPassword)
	}
	membersRouter := router.Group("/members")
	{
		membersRouter.GET("", r.GetAll)
		membersRouter.PUT("", r.ActivateAll)
		membersRouter.DELETE("", r.DeleteAll)

		membersRouter.GET("/count", r.Count)
		membersRouter.GET("/nickname", r.SearchKeyNickname)
	}
}

var Router memberHandler
